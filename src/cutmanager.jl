export AbstractCutManager

abstract AbstractCutManager{S}

function ncuts(man::AbstractCutManager)
  return length(get(man.cuts_de))
end

function isfeasibilitycut(man::AbstractCutManager, cut)
  if length(man.σs) < length(man.ρs)
    cut in man.σs
  else
    !(cut in man.ρs)
  end
end

function init!(man::AbstractCutManager, mycut_d, mycut_e)
  mycut = [mycut_d; mycut_e]
  man.trust = Float64[initialtrust(man, mc) for mc in mycut]
end

function start!(man::AbstractCutManager, cuts_D, cuts_E, cuts_d, cuts_e, mycut_d, mycut_e)
  man.nσ = length(cuts_d)
  man.nρ = length(cuts_e)
  man.cuts_DE = [cuts_D; cuts_E]
  man.cuts_de = [cuts_d; cuts_e]
  man.σs = collect(1:man.nσ)
  man.ρs = collect(man.nσ+(1:man.nρ))
  init!(man, mycut_d, mycut_e)
end

function isstarted(man::AbstractCutManager)
  @assert isnull(man.cuts_DE) == isnull(man.cuts_de)
  !isnull(man.cuts_DE)
end

# COMPARISON
gettrust(man::AbstractCutManager) = man.trust

function choosecutstoremove(man::AbstractCutManager, num)
  # MergeSort is stable so in case of equality, the oldest cut loose
  # However PartialQuickSort is a lot faster

  trust = gettrust(man)
  if num == 1
    [indmin(trust)]                   # indmin selects the oldest cut in case of tie -> good :)
  else
    sortperm(trust, alg=PartialQuickSort(num))[1:num] # PartialQuickSort is unstable ->  bad :(
  end
end

isbetter(man::AbstractCutManager, i::Int, mycut::Bool) = gettrust(man)[i] > initialtrust(man, mycut)

# CHANGE

# Add cut ax >= β
# If fc then it is a feasibility cut, otherwise it is an optimality cut
# If mycut then the cut has been added because of one of my trials
function addcuts!{S}(man::AbstractCutManager{S}, A::AbstractMatrix{S}, b::AbstractVector{S}, isfc::Bool, mycut::Vector{Bool})
  nnew = size(A, 1)
  @assert length(mycut) == length(b) == nnew
  @assert nnew > 0
  status = Symbol[:Pushed for i in 1:nnew]

  if man.maxncuts != -1 && ncuts(man)+nnew > man.maxncuts
    # Need to remove some cuts
    J = choosecutstoremove(man, ncuts(man) + nnew - man.maxncuts)

    # Check if some new cuts should be ignored
    take = man.maxncuts - ncuts(man)
    j = length(J)
    nmycut = sum(mycut)
    while j > 0 && take < nnew
      # I first try to see if the nmycut cuts generated by me can be taken
      # because they have better trust than the nnew-nmycut others
      if isbetter(man, J[j], take < nmycut)
        j -= 1
      else
        take += 1
      end
    end
    J = J[1:j]
    if take < size(A, 1) || length(J) < length(b)
      if take < size(A, 1)
        # Remove ignored cuts
        takemycut = min(take, nmycut)
        takenotmycut = take - takemycut
        takeit = zeros(Bool, nnew)
        for i in 1:nnew
          ok = false
          if mycut[i]
            if takemycut > 0
              takemycut -= 1
              ok = true
            end
          else
            if takenotmycut > 0
              takenotmycut -= 1
              ok = true
            end
          end
          if ok
            takeit[i] = true
          else
            status[i] = :Ignored
          end
        end

        takeit = find(takeit)
      else
        takeit = collect(1:nnew)
      end
      nreplaced = min(length(J), length(takeit))
      replaced = takeit[1:nreplaced]
      pushed = takeit[(nreplaced+1):end]

      status[replaced] = :Replaced
      Ar = A[replaced,:]
      br = b[replaced]
      mycutr = mycut[replaced]
      A = A[pushed,:]
      b = b[pushed]
      mycut = mycut[pushed]
    else
      Ar = A
      br = b
      mycutr = mycut
      A = similar(A, 0, size(A, 2))
      b = similar(b, 0)
      mycut = similar(mycut, 0)
    end
    if !isempty(br)
      if length(br) == length(J)
        js = J
        J = []
      else
        @assert length(br) < length(J)
        js = J[(length(J) - length(br) + 1):end]
      end
      get(man.cuts_DE)[js,:] = Ar
      get(man.cuts_de)[js] = br
      replacecuts!(man, js, mycutr)
      cutadded = true
      needupdate_σsρs = reduce(|, false, Bool[isfc $ isfeasibilitycut(man, j) for j in js])
    else
      cutadded = false
      needupdate_σsρs = false
    end

    if !isempty(J) || needupdate_σsρs
      keep = ones(Bool, ncuts(man))
      keep[J] = false
      K = find(keep)
      isσcut = zeros(Bool, ncuts(man))
      isσcut[man.σs] = true
      if cutadded
        isσcut[js] = isfc
      end
      isσcut = isσcut[K]
      man.σs = (1:length(isσcut))[isσcut]
      man.ρs = (1:length(isσcut))[!isσcut]
      man.nσ = length(man.σs)
      man.nρ = length(man.ρs)
    end

    if !isempty(J)
      man.cuts_DE = get(man.cuts_DE)[K,:]
      man.cuts_de = get(man.cuts_de)[K]
      keeponly!(man, K)
    end
  end

  if !isempty(b)
    # Just append cuts
    if isfc
      append!(man.σs, man.nσ + man.nρ + (1:nnew))
      man.nσ += nnew
    else
      append!(man.ρs, man.nσ + man.nρ + (1:nnew))
      man.nρ += nnew
    end
    man.cuts_DE = [get(man.cuts_DE); A]
    man.cuts_de = [get(man.cuts_de); b]
    pushcuts!(man, mycut)
  end

  status
end

function keeponly!(man::AbstractCutManager, K::Vector{Int})
  man.trust = man.trust[K]
end

function initialtrusts(man::AbstractCutManager, mycut::Vector{Bool})
  Float64[initialtrust(man, mc) for mc in mycut]
end

function replacecuts!(man::AbstractCutManager, js::Vector{Int}, mycut::Vector{Bool})
  man.trust[js] = initialtrusts(man, mycut)
end

function pushcuts!(man::AbstractCutManager, mycut::Vector{Bool})
  append!(man.trust, initialtrusts(man, mycut))
end
